<!DOCTYPE HTML>
<meta charset= "utf-8">
<html>
<head>
<script type="text/javascript" src="canvas/canvasjs.min.js"></script>
<script type="text/javascript"> 

function xmlhttp_request(cgi, request, callback)
{
	var url = "http://aurora.cs.uaf.edu/cgi-bin/" + cgi + "?r=" +JSON.stringify(request);
	var xmlhttp = new XMLHttpRequest();
	//var pw = "NOPE";
	xmlhttp.open("GET",url,true);

	xmlhttp.onreadystatechange=function()
	{
		if(xmlhttp.readyState==4&&xmlhttp.status==200)
		{
			try
			{
				callback(JSON.parse(xmlhttp.responseText));
			}

			catch(e)
			{}
		}
	}
	xmlhttp.send(null);
}

function get_cr_current_year ()
{
	var current_year = new Date().getFullYear();
	var request_obj = {year:current_year};
	var rotation_index_ranges = {};

	xmlhttp_request("cr_cgi.py", request_obj, function(obj) {
	get_cr_next_year(obj);			
	});
}

function get_cr_next_year (current_year_obj)
{
	var next_year = new Date().getFullYear() + 1;
	var request_obj = {year:next_year};
	var rotation_index_ranges = {};

	xmlhttp_request("cr_cgi.py", request_obj, function(obj){
	var cr_date_ranges = get_cr_month_range (current_year_obj, obj);
	get_kp_data("d3", cr_date_ranges, function(d3obj){
	get_kp_data("d28", cr_date_ranges, function(d28obj){
	draw_charts(d3obj, d28obj, cr_date_ranges);
	});
	});
	});
}

function get_cr_month_range (current_year_obj, next_year_obj)
{
	var date = new Date();
	for (var ii = 0; ii < current_year_obj.values.length; ii ++)
	{
		var start= new Date(
		current_year_obj.values[ii].year,
		current_year_obj.values[ii].month - 1, // from 0-indexed to 1-indexed
		parseInt(current_year_obj.values[ii].day));

	var end = {}; 
		if(ii == current_year_obj.values.length - 1)
		{
			end = new Date(
			next_year_obj.values[0].year,
			next_year_obj.values[0].month - 1,
			parseInt(next_year_obj.values[0].day));
		}
		else
		{	
			end = new Date(
			current_year_obj.values[ii+1].year,
			current_year_obj.values[ii+1].month - 1,
			parseInt(current_year_obj.values[ii+1].day));
		}
		
		if(start <= date && end >= date)
		{
			var cr_index = current_year_obj.values[ii].rotation_index;
			return {start_date: start, end_date: end, rotation_index: cr_index};
		}
	}
	return  {};
}

function get_kp_data(forecast, cr_date_ranges, callback)
{
	var year = cr_date_ranges.start_date.getFullYear();

	request_data(forecast, cr_date_ranges, year, function(kp){
		callback(kp);
	});
}

function request_data(type, cr_date_ranges, year, callback)
{
	var kp_array = new Array;
	var time = new Date();
	var current_month = time.getMonth() + 1; // convert from 0-indexed

	var request_obj={};
	request_obj.forecast=type;
	request_obj.predicted_time={newest:true, year:year,month:-1 ,day:-1,hour:-1,minute:-1};
	xmlhttp_request("kp_cgi.py", request_obj, function(obj){
	if(obj.values.length>0)
	{
		for (var i=0, len = obj.values.length; i < len; i++)
		{

			kp_array.push({date_obj:obj.values[i].predicted_time, kp_val:obj.values[i].kp});
		}
	}
	callback(kp_array);
	});
}

function format_date(obj, callback)
{
	// Apparently there's no good way to get abbreviated date month name from Date.
	Date.prototype.monthName = function() {
		return this.toUTCString().split(' ')[2]
	};

	callback(obj.monthName() + ". " + obj.getDate() + ", " + obj.getFullYear());
}

function draw_charts(d3arr, d28arr, cr_date_ranges) 
{ 
	d3arr.sort(function (a, b)
	{
		return (a.kp_val - b.kp_val);
	});
	
	CanvasJS.addColorSet("colors", ["grey", "green", "yellow", "red"]);  
	var forecast = new CanvasJS.Chart("chartContainer1", {colorSet: "colors", zoomEnabled: true });  

	var rotation = cr_date_ranges.rotation_index;

	var cr_start_date = new Date(cr_date_ranges.start_date);
	format_date(cr_start_date, function(start_date){

	var cr_end_date = new Date(cr_date_ranges.end_date);
	format_date(cr_end_date, function(end_date){
	
	forecast.options.title = { text: "Carrington Rotation #" + rotation 
		+ ": " + start_date + " - " + end_date}; 
	forecast.options.axisY = { title: "Estimated Kp Index", gridColor: "lightgrey" }; 
	forecast.options.axisX = { valueFormatString: "MMM DD", interval: 3, intervalType: "day", labelAngle: -45}; 

	

	var d28_series = {  
		markerType: "none", 
		type: "stepLine", 
		name: "28-day forecast", 
		showInLegend: true, 
		color: "darkblue",
	}; 

	var d3_series = { 
		type: "column", 
		name: "3-day forecast", 
		showInLegend: true, 
	}; 

	forecast.options.data = []; 
	forecast.options.data.push(d3_series); 
	forecast.options.data.push(d28_series); 

	d28_series.dataPoints = [];
	d3_series.dataPoints = [];
	
		
	for (var i=0; i < d28arr.length; ++i)
	{
	
		 
		var begin_day = new Date(d28arr[i].date_obj.year,
				d28arr[i].date_obj.month - 1,
				d28arr[i].date_obj.day,
				0, 0);
		var end_day =  new Date(d28arr[i].date_obj.year,
				d28arr[i].date_obj.month - 1,
				d28arr[i].date_obj.day,
				23, 59);
		if (begin_day < cr_start_date) { continue;};
		if (end_day > cr_end_date) { continue;};

		d28_series.dataPoints.push({x:begin_day, y: d28arr[i].kp_val});
		d28_series.dataPoints.push({x:end_day, y: d28arr[i].kp_val});
		++i;
	}


	for (var i=0; i < d3arr.length; ++i) 
	{
		var date_entry = new Date(d3arr[i].date_obj.year,
				d3arr[i].date_obj.month - 1,
				d3arr[i].date_obj.day,
				Math.floor((d3arr[i].date_obj.hour-1) / 3 ) * 3) ; 
		var color = "green";
		if (date_entry < cr_start_date || date_entry > cr_end_date) { continue;};

		if (d3arr[i].kp_val >= 3)
		{
			color = "yellow";
		}
		if (d3arr[i].kp_val > 4)
		{
			color = "red";
		}
		d3_series.dataPoints.push({ x:date_entry, y: d3arr[i].kp_val, color:color});
	}

	forecast.render();
	}); 
	});
}

window.onload = get_cr_current_year();
</script>
</head>

<body>
<div id="chartContainer1" style="height: 350px; width: 100%;"></div>
<div id="chartContainer2" style="height: 350px; width: 100%;"></div>
</body>
</html>

