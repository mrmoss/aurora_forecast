<!--
	#WebGl Based Aurora Simulation
	#	Created By:		Paul Gentemann, Caleb Hellickson, Ruslan Kolesnik, Ignacio Saez Lahidalga, and Mike Moss
	#	Modified On:	04/08/2014
-->

<!doctype html>

<html>

	<!--Head-->
	<head>

		<!--Unicode 8 Compliant-->
		<meta charset="utf-8">

		<!--Three.js Source-->
		<script src="js/three.min.js"></script>

		<!--Aurora Simulation Source-->
		<script type="text/javascript">

			//Site Globals
			var root="";
			var width=800;
			var height=600;
			var locations=new Array();
			locations.push({name:"Fairbanks, AK",latitude:64.8436,longitude:-147.7231});
			locations.push({name:"Adelaide",latitude:-34.9333300,longitude:138.6});

			//Three.js Globals
			var renderer;
			var scene;
			var camera;
			var universe;

			//Simulation Globals
			var kp=0;
			var view_latitude=0;
			var view_longitude=0;
			var view_latitude_to=0;
			var view_longitude_to=0;
			var view_latitude_down=0;
			var view_longitude_down=0;
			var zoom=2;
			var zoom_min=0.7;
			var zoom_max=3;

			//Input Globals
			var mouse_down=false;
			var mouse_down_x=0.0;
			var mouse_down_y=0.0;

			//Setup Function (Happens Once)
			function setup()
			{
				//Setup Input Callbacks
				var canvas=document.getElementById("canvas");
				canvas.addEventListener('mouseout',mouse_leave_window_callback,false);
				canvas.addEventListener('mousewheel',mouse_wheel_callback,false);
				canvas.addEventListener('DOMMouseScroll',mouse_wheel_callback,false);
				canvas.addEventListener('mousedown',mouse_down_callback,false);
				canvas.addEventListener('mouseup',mouse_up_callback,false);
				canvas.addEventListener('mousemove',mouse_move_callback,false);
				canvas.addEventListener('mouseover',mouse_over_callback,false);

				//Initialize Kp Shader Uniform
				kp=new THREE.Vector2(0.0,0.0);

				//Get Canvas Object
				var canvas=document.getElementById('canvas');
				canvas.innerHTML="";

				//Create Renderer
				renderer=new THREE.WebGLRenderer();
				renderer.setSize(width,height);
				canvas.appendChild(renderer.domElement);

				//Create Scene
				scene=new THREE.Scene();

				//Create Camera
				camera=new THREE.PerspectiveCamera(45,width/height,0.01,1000);
				camera.position.x=0;
				camera.position.y=0;
				camera.position.z=5;

				//Create Universe
				universe=create_universe(scene,0.5,24);

				//Setup Locations
				setup_locations();

				//Go to Default Location
				if(locations.length>0)
				{
					view_latitude_to=locations[0].latitude;
					view_longitude_to=locations[0].longitude;
				}

				//Start Rendering
				render();
			}

			//Render Function (Happens Every Frame Update)
			function render()
			{
				//Limit Latitude
				if(view_latitude>=90)
					view_latitude=89.99;
				if(view_latitude<=-90)
					view_latitude=-89.99;
				if(view_latitude_to>=90)
					view_latitude_to=89.99;
				if(view_latitude_to<-90)
					view_latitude_to=-90;

				//Auto Move Location (P Controller)
				var move_speed=0.1;
				view_latitude+=(view_latitude_to-view_latitude)*move_speed;
				view_longitude+=(view_longitude_to-view_longitude)*move_speed;

				//Update Camera
				var look_at_x=Math.sin((90-view_latitude)/180*Math.PI)*Math.cos(Math.PI/2+
					(270-view_longitude)/180*Math.PI)*zoom;
				var look_at_y=Math.cos((90-view_latitude)/180*Math.PI)*zoom;
				var look_at_z=Math.sin((90-view_latitude)/180*Math.PI)*Math.sin(Math.PI/2+
					(270-view_longitude)/180*Math.PI)*zoom;
				camera.position.x=look_at_x;
				camera.position.y=look_at_y;
				camera.position.z=look_at_z;
				camera.lookAt(universe.planet.position);

				//Update Marker
				var marker_radius=0.51;
				universe.marker.position.x=
					Math.sin((90-universe.marker.latitude)/180*Math.PI)*Math.cos(Math.PI/2+
					(270-universe.marker.longitude)/180*Math.PI)*marker_radius;
				universe.marker.position.y=
					Math.cos((90-universe.marker.latitude)/180*Math.PI)*marker_radius;
				universe.marker.position.z=
					Math.sin((90-universe.marker.latitude)/180*Math.PI)*Math.sin(Math.PI/2+
					(270-universe.marker.longitude)/180*Math.PI)*marker_radius;

				//Update North Pole Aurora
				universe.aurora_north.rotation.x=universe.planet.rotation.x-1.44;
				universe.aurora_north.rotation.y=universe.planet.rotation.y+0.07;
				universe.aurora_north.rotation.z=universe.planet.rotation.z;

				//Update South Pole Aurora
				universe.aurora_south.rotation.x=universe.planet.rotation.x+1.89;
				universe.aurora_south.rotation.y=universe.planet.rotation.y+0.06;
				universe.aurora_south.rotation.z=universe.planet.rotation.z-2.52;

				//Update North Pole Aurora View Line
				universe.view_line_north.rotation.x=universe.aurora_north.rotation.x;
				universe.view_line_north.rotation.y=universe.aurora_north.rotation.y;
				universe.view_line_north.rotation.z=universe.aurora_north.rotation.z;

				//Update South Pole Aurora View Line
				universe.view_line_south.rotation.x=universe.aurora_south.rotation.x;
				universe.view_line_south.rotation.y=universe.aurora_south.rotation.y;
				universe.view_line_south.rotation.z=universe.aurora_south.rotation.z;

				//Update Clouds
				universe.clouds.rotation.y+=0.0001;

				//Update Sun
				var time_obj=get_time();
				var time_now=time_obj.hour*60*60+time_obj.minute*60+time_obj.second;
				var time_max=24*60*60;
				universe.sun.longitude=time_now/time_max*360-180;
				universe.sun.latitude=0;

				while(universe.sun.longitude>180)
					universe.sun.longitude-=360;
				while(universe.sun.longitude<-180)
					universe.sun.longitude+=360;

				var sun_radius=10;
				var sun_x=Math.sin((90-universe.sun.latitude)/180*Math.PI)*Math.cos(Math.PI/2+
					(270-universe.sun.longitude)/180*Math.PI)*sun_radius;
				var sun_y=Math.cos((90-universe.sun.latitude)/180*Math.PI)*sun_radius;
				var sun_z=Math.sin((90-universe.sun.latitude)/180*Math.PI)*Math.sin(Math.PI/2+
					(270-universe.sun.longitude)/180*Math.PI)*sun_radius;
				universe.sun.position.set(sun_x,sun_y,sun_z);

				//Render
				requestAnimationFrame(render);
				renderer.render(scene,camera);

				//TESTING
				kp.x=parseFloat(document.getElementById("kp").value);

				//TESTING
				var str="";
				var view_longitude_show=view_longitude;

				while(view_longitude_show>180)
					view_longitude_show-=360;
				while(view_longitude_show<-180)
					view_longitude_show+=360;

				str+="lat:\t"+view_latitude+"\n";
				str+="lng:\t"+view_longitude_show+"\n";
				str+="zoom:\t"+zoom+"\n";
				str+="kp:\t"+kp.x;
				document.getElementById("dump").value=str;
			}

			//Create Universe Function (Creates Earth Scene)
			function create_universe(scene,radius,segments)
			{
				//Create Star Background
				var ret={};

				ret.stars=new THREE.Mesh
				(
					new THREE.SphereGeometry(90,segments,segments+1),
					new THREE.MeshBasicMaterial
					({
						map:  THREE.ImageUtils.loadTexture(root+"images/galaxy_starfield.png"),
						side: THREE.BackSide
					})
				);

				scene.add(ret.stars);

				//Create Planet Earth
				ret.planet=new THREE.Mesh
				(
					new THREE.SphereGeometry(radius,segments,segments+1),
					new THREE.MeshPhongMaterial
					({
						map:         THREE.ImageUtils.loadTexture(root+"images/2_no_clouds_4k.jpg"),
						bumpMap:     THREE.ImageUtils.loadTexture(root+"images/elev_bump_4k.jpg"),
						bumpScale:   0.005,
						specularMap: THREE.ImageUtils.loadTexture(root+"images/water_4k.png"),
						specular:    new THREE.Color('grey')
					})
				);

				scene.add(ret.planet);

				//Create Cloud Layer
				ret.clouds=new THREE.Mesh
				(
					new THREE.SphereGeometry(radius+0.003*2,segments,segments+1),
					new THREE.MeshPhongMaterial
					({
						map:         THREE.ImageUtils.loadTexture(root+"images/fair_clouds_4k.png"),
						transparent: true
					})
				);

				scene.add(ret.clouds);

				//Create Marker
				ret.marker=new THREE.Mesh
				(
					new THREE.SphereGeometry(0.015,segments,segments+1),
					new THREE.MeshNormalMaterial
					({
						color:       new THREE.Color(0xffff00)
					})
				);

				ret.marker.latitude=0;
				ret.marker.longitude=0;
				scene.add(ret.marker);

				//Create Northern Auroral Oval
				ret.aurora_north=new THREE.Mesh
				(
					new THREE.SphereGeometry(radius+0.003*4,segments,segments+1),
					new THREE.ShaderMaterial
					({
						transparent: true,
						uniforms:
						{
							kp:{type:"v2",value:kp},
							view_type:{type:"i",value:0}
						},
						vertexShader: document.getElementById('vertex_shader').textContent,
						fragmentShader: document.getElementById('fragment_shader').textContent
					})
				);

				scene.add(ret.aurora_north);

				//Create Southern Auroral Oval
				ret.aurora_south=new THREE.Mesh
				(
					new THREE.SphereGeometry(radius+0.003*6,segments,segments+1),
					new THREE.ShaderMaterial
					({
						transparent: true,
						uniforms:
						{
							kp:{type:"v2",value:kp},
							view_type:{type:"i",value:0}
						},
						vertexShader: document.getElementById('vertex_shader').textContent,
						fragmentShader: document.getElementById('fragment_shader').textContent
					})
				);

				scene.add(ret.aurora_south);

				//Create Northern View Line
				ret.view_line_north=new THREE.Mesh
				(
					new THREE.SphereGeometry(radius+0.003*8,segments,segments+1),
					new THREE.ShaderMaterial
					({
						transparent: true,
						uniforms:
						{
							kp:{type:"v2",value:kp},
							view_type:{type:"i",value:1}
						},
						vertexShader: document.getElementById('vertex_shader').textContent,
						fragmentShader: document.getElementById('fragment_shader').textContent
					})
				);

				scene.add(ret.view_line_north);

				//Create Southern View Line
				ret.view_line_south=new THREE.Mesh
				(
					new THREE.SphereGeometry(radius+0.003*10,segments,segments+1),
					new THREE.ShaderMaterial
					({
						transparent: true,
						uniforms:
						{
							kp:{type:"v2",value:kp},
							view_type:{type:"i",value:1}
						},
						vertexShader: document.getElementById('vertex_shader').textContent,
						fragmentShader: document.getElementById('fragment_shader').textContent
					})
				);

				scene.add(ret.view_line_south);

				//Create Ambient Light
				ret.ambient_light=new THREE.AmbientLight(0x444444);
				scene.add(ret.ambient_light);

				//Create Sun Light
				ret.sun=new THREE.DirectionalLight(0xffffff,1.5);
				ret.sun.position.set(0,0,0);
				ret.sun.latitude=0;
				ret.sun.longitude=0;
				scene.add(ret.sun);

				//Return Scene
				return ret;
			}

			//Set Location
			function set_location()
			{
				//Set "To" Location
				view_latitude_to=locations[document.getElementById("locations").selectedIndex].latitude;
				view_longitude_to=locations[document.getElementById("locations").selectedIndex].longitude;

				//Limit Longitude Wrap Around
				while(view_longitude>180)
					view_longitude-=360;
				while(view_longitude<-180)
					view_longitude+=360;

				//Set Marker Location
				universe.marker.latitude=view_latitude_to;
				universe.marker.longitude=view_longitude_to;
			}

			//TESTING
			function show_members(obj)
			{
				var methods=[];

				for (var m in obj)
					if (typeof obj[m]=="function"&&obj.hasOwnProperty(m))
						methods.push(m);

				alert(methods.join(","));
			}

			//Get Time Function
			function get_time()
			{
				var date=new Date();

				var ret={};
				ret.second=date.getUTCSeconds();
				ret.minute=date.getUTCMinutes();
				ret.hour=date.getUTCHours();
				ret.day=date.getUTCDay();
				ret.year=date.getFullYear()

				return ret;
			}

			//Setup Locations Function
			function setup_locations()
			{
				//Update Location Options
				update_location_options();

				//Update Live Location
				set_location();

				//Get Current Location
				navigator.geolocation.getCurrentPosition(get_current_location);
			}

			//Get Current Location Callback
			function get_current_location(location)
			{
				//Add Current Location
				locations.push({name:"My Location",latitude:location.coords.latitude,
					longitude:location.coords.longitude});

				//Update Location Options
				update_location_options();
			}

			//Update Location Options Function
			function update_location_options()
			{
				//Clear Out Old Options
				document.getElementById("locations").options.length=0;

				//Add Locations
				for(var ii=0;ii<locations.length;++ii)
					document.getElementById("locations").options[ii]=new Option(locations[ii].name);
			}

			//Mouse Leave Window Callback
			function mouse_leave_window_callback(event)
			{
				event=event?event:window.event;

				var from=event.relatedTarget||event.toElement;

				if(!from||from.nodeName == "HTML")
					mouse_down=false;
			}

			//Mouse Wheel Callback
			function mouse_wheel_callback(event)
			{
				var canvas=document.getElementById("canvas");

				if(event.target!=canvas)
				{
					zoom+=event.detail*0.01;

					if(zoom>zoom_max)
						zoom=zoom_max;
					if(zoom<zoom_min)
						zoom=zoom_min;
				}
			}

			//Mouse Down Callback
			function mouse_down_callback(event)
			{
				var canvas=document.getElementById("canvas");

				if(event.target!=canvas)
				{
					mouse_down=true;
					view_latitude_down=view_latitude;
					view_longitude_down=view_longitude;
					mouse_down_x=event.pageX-canvas.offsetLeft;
					mouse_down_y=event.pageY-canvas.offsetTop;
				}
			}

			//Mouse Up Callback
			function mouse_up_callback(event)
			{
				mouse_down=false;
			}

			//Mouse Move Callback
			function mouse_move_callback(event)
			{
				var canvas=document.getElementById("canvas");

				if(mouse_down)
				{
					var mouse_x=event.pageX-canvas.offsetLeft;
					var mouse_y=event.pageY-canvas.offsetTop;

					view_latitude_to=view_latitude_down+mouse_y-mouse_down_y;
					view_longitude_to=view_longitude_down+mouse_down_x-mouse_x;
				}
			}

			//Mouse Over Callback
			function mouse_over_callback(event)
			{
				if(event.target==canvas)
					mouse_down=false;
			}

		</script>

		<!--GLSL Vertex Shader Source-->
		<script id="vertex_shader" type="x-shader/x-vertex">

			//UV Coordinates
			varying vec2 uv_coords;

			//Main
			void main()
			{
				//Pass UV Coordinates to Fragment Shader
				uv_coords=uv;

				//Calculate Position
				gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
			}

		</script>

		<!--GLSL Fragment Shader Source-->
		<script id="fragment_shader" type="x-shader/x-fragment">

			//UV Coordinates
			varying vec2 uv_coords;
			vec2 uv_coords_scaled=vec2(uv_coords.x*2.0,uv_coords.y);
			vec2 screen_center=vec2(0.5,0.5);

			//Uniforms
			uniform vec2 kp;
			uniform int view_type;

			//Map Function (Linear Interpolatation)
			float map(float x,float in_min,float in_max,float out_min,float out_max)
			{
				return (x-in_min)*(out_max-out_min)/(in_max-in_min)+out_min;
			}

			//Draw Circle Function
			float draw_circle(const float radius,const float thickness)
			{
				float radial_distance=abs(distance(uv_coords_scaled,screen_center));
				float ring_distance=abs(radial_distance-radius);
				float color=map(ring_distance,0.0,thickness/2.0,1.0,0.2);
				return color;
			}

			//Draw Aurora Function
			void draw_aurora(const float radius,const float thickness)
			{
				float color=draw_circle(radius,thickness);
				gl_FragColor=vec4(color-0.3,color,0.0,color);
			}

			//Draw View Line Function
			void draw_view_line(const float radius,const float thickness)
			{
				float color=draw_circle(radius,thickness);
				gl_FragColor=vec4(color,0.0,0.0,color);
			}

			//Main
			void main()
			{
				//Aurora Variables
				float aurora_radius=0.11+kp.x*0.01;
				float aurora_thickness=0.02+kp.x*0.03;

				//View Line Variables
				float view_line_radius=aurora_radius+0.03+kp.x*0.00975;
				float view_line_thickness=0.01;

				//Draw Aurora (0)
				if(view_type==0)
					draw_aurora(aurora_radius,aurora_thickness);

				//Draw View Line (1)
				else if(view_type==1)
					draw_view_line(view_line_radius,view_line_thickness);

				//Discard Otherwise
				else
					discard;
			}

		</script>

	</head>

	<!--Body-->
	<body onload="setup();">

		<!--Simulation Canvas-->
		<div id="canvas"></div>
		<br/>

		<!--TESTING-->
		<table>
			<tr style="vertical-align:top;">
				<td>
					debug data:<br/>
					<textarea id="dump" rows="10" cols="60"></textarea><br/>
				</td>
				<td>
					tools:<br/>
					kp:<input type="range" id="kp" min="0" max="9" step="0.01" value="0"/><br/>
					location:<select id="locations" onmouseup="set_location();"></select>
				</td>
			</tr>
		</table>

	</body>

</html>