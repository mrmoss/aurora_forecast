<!--
	#WebGl Based Aurora Simulation
	#	Created By:		Paul Gentemann, Caleb Hellickson, Ruslan Kolesnik, Ignacio Saez Lahidalga, and Mike Moss
	#	Modified On:	04/26/2014


	Works On:
		Windows:
			Firefox
			IE 9+
			Chrome
			Opera

		Linux:
			Firefox
			Chrome

		MacOs:
			Firefox
			Safari
				Config
					Preferences
						Advanced
							Show Develop menu in menu bar.
					Show Menu Bar
				Develop
					Enable WebGl
			Chrome

		Android:
			Firefox
			Chrome
				chrome://flags/#enable-webgl

		IOS:

	Doesn't Work On?:
		Windows:
			Safari
			IE 6/7/8

		Android:
			Default Browser
-->

<!doctype html>

<html>

	<!--Head-->
	<head>

		<!--Unicode 8 Compliant-->
		<meta charset="utf-8">

		<!--Hammer.js Source-->
		<script src="js/hammer.min.js"></script>

		<!--JSZip Source-->
		<script src="js/jszip.min.js"></script>

		<!--Three.js Source-->
		<script src="js/three.min.js"></script>
		<script src="js/Detector.js"></script>

		<!--Aurora Simulation Source-->
		<script type="text/javascript">

			//Site Globals
			var root="http://aurora.cs.uaf.edu/sites/simulation/";
			//root="";
			var width= 300;
			var height= 300;
			var earth_radius=0.5;
			var locations=new Array();
			var forecast="none";
			var fallback_locations=new Array();
			var fallback_locations_index=0;
			var use_fallback=false;

			//Create Locations
			locations.push({name:"Fairbanks, AK",latitude:64.8436,longitude:-147.7231});
			locations.push({name:"Adelaide",latitude:-34.9333300,longitude:138.6});

			//2D Fallback Locations
			fallback_locations.push({name:"Alaska",latitude:64.8436,longitude:-147.7231,zoom:0.84});
			fallback_locations.push({name:"United States",latitude:37.28,longitude:-100.61,zoom:1.06});
			fallback_locations.push({name:"Europe",latitude:50.41,longitude:10.03,zoom:1.06});
			fallback_locations.push({name:"North Polar",latitude:65.41,longitude:-66.975,zoom:1.42});
			fallback_locations.push({name:"South Polar",latitude:-83.02,longitude:108.81,zoom:1.3});

			//Three.js Globals
			var renderer;
			var scene;
			var camera;
			var universe;

			//Simulation Globals
			var kp=new THREE.Vector2(-1.0,0.0);
			var view_latitude=0;
			var view_longitude=0;
			var view_latitude_to=0;
			var view_longitude_to=0;
			var view_latitude_down=0;
			var view_longitude_down=0;
			var zoom=2;
			var zoom_min=0.7;
			var zoom_max=3;
			var touches=0;
			var zoom_down=zoom;
			var scale_down=0;
			var show_stars=false;
			var show_sun=false;

			//Download Globals
			var zip;

			//Input Globals
			var mouse_down=false;
			var mouse_down_x=0.0;
			var mouse_down_y=0.0;

			//Setup Function (Happens Once)
			function setup()
			{
				//Get Forecast
				if(parent.forecast)
					forecast=parent.forecast;

				//Update Forecast
				setInterval(update_kp,1000);

				//Set Resize Callback
				if(parent.window)
					parent.window.addEventListener('resize',resize_function);

				//Detect WebGL
				if(!Detector.webgl)
				{
					use_fallback=true;
					//Detector.addGetWebGLMessage();
				}

				//Use WebGL
				if(!use_fallback)
				{
					//Get Canvas Div
					var canvas=document.getElementById("canvas");
					canvas.innerHTML="";

					//Enable Mobile Zooming
					Hammer(canvas).on
					(
						"pinch",
						function(e)
						{
							if(e.gesture.eventType==Hammer.EVENT_START)
							{
								zoom_down=zoom;
								scale_down=e.gesture.scale;
							}

							zoom=zoom_down+(scale_down-e.gesture.scale)*0.5;
							e.preventDefault();
						}
					);

					//Setup Input Callbacks
					mouse_scroll_init("canvas");
					canvas.addEventListener('mouseout',mouse_leave_window_callback,false);
					canvas.addEventListener('mousedown',mouse_down_callback,false);
					canvas.addEventListener('mouseup',mouse_up_callback,false);
					canvas.addEventListener('mousemove',mouse_move_callback,false);
					canvas.addEventListener('mouseover',mouse_over_callback,false);
					canvas.addEventListener('touchleave',touch_leave_window_callback,false);
					canvas.addEventListener('touchstart',touch_down_callback,false);
					canvas.addEventListener('touchend',touch_up_callback,false);
					canvas.addEventListener('touchmove',touch_move_callback,false);
					canvas.addEventListener('touchenter',touch_over_callback,false);

					//Create Renderer
					renderer=new THREE.WebGLRenderer({preserveDrawingBuffer:true});
					canvas.appendChild(renderer.domElement);

					//Create Scene
					scene=new THREE.Scene();

					//Create Camera
					camera=new THREE.PerspectiveCamera(45,width/height,0.01,1000);
					camera.position.x=0;
					camera.position.y=0;
					camera.position.z=5;

					//Create Universe
					universe=create_universe(scene,earth_radius,32);

					//Setup Locations
					setup_locations();

					//Go to Default Location
					if(locations.length>0)
					{
						view_latitude_to=locations[0].latitude;
						view_longitude_to=locations[0].longitude;
					}

					//Start Rendering
					render();
				}

				//Use Fallback
				else
				{
					//Setup Locations
					setup_locations();

					//Render Fallback
					render_fallback();
				}

				//Resize Simulation
				resize_function();
			}

			//Render Function (Happens Every Frame Update)
			function render()
			{
				//Limit Number of Touches
				if(touches>1&&mouse_down)
					mouse_down=false;

				//Limit Zoom
				if(zoom>zoom_max)
					zoom=zoom_max;
				if(zoom<zoom_min)
					zoom=zoom_min;

				//Limit Latitude
				if(view_latitude>=90)
					view_latitude=89.99;
				if(view_latitude<=-90)
					view_latitude=-89.99;
				if(view_latitude_to>=90)
					view_latitude_to=89.99;
				if(view_latitude_to<-90)
					view_latitude_to=-90;

				//Auto Move Location (P Controller)
				var move_speed=0.1;
				view_latitude+=(view_latitude_to-view_latitude)*move_speed;
				view_longitude+=(view_longitude_to-view_longitude)*move_speed;

				//Update Camera
				var look_at_x=Math.sin((90-view_latitude)/180*Math.PI)*Math.cos(Math.PI/2+
					(270-view_longitude)/180*Math.PI)*zoom;
				var look_at_y=Math.cos((90-view_latitude)/180*Math.PI)*zoom;
				var look_at_z=Math.sin((90-view_latitude)/180*Math.PI)*Math.sin(Math.PI/2+
					(270-view_longitude)/180*Math.PI)*zoom;
				camera.position.x=look_at_x;
				camera.position.y=look_at_y;
				camera.position.z=look_at_z;
				camera.lookAt(universe.planet.position);

				//Update Marker
				var marker_radius=earth_radius+universe.marker.radius/2.0;
				universe.marker.position.x=
					Math.sin((90-universe.marker.latitude)/180*Math.PI)*Math.cos(Math.PI/2+
					(270-universe.marker.longitude)/180*Math.PI)*marker_radius;
				universe.marker.position.y=
					Math.cos((90-universe.marker.latitude)/180*Math.PI)*marker_radius;
				universe.marker.position.z=
					Math.sin((90-universe.marker.latitude)/180*Math.PI)*Math.sin(Math.PI/2+
					(270-universe.marker.longitude)/180*Math.PI)*marker_radius;

				//Update North Pole Aurora
				universe.aurora_north.rotation.x=universe.planet.rotation.x-1.5;
				universe.aurora_north.rotation.y=universe.planet.rotation.y+0.04;
				universe.aurora_north.rotation.z=universe.planet.rotation.z+0.49

				//Update South Pole Aurora
				universe.aurora_south.rotation.x=universe.planet.rotation.x+1.8805985402277465;
				universe.aurora_south.rotation.y=universe.planet.rotation.y-0.11217274015818644;
				universe.aurora_south.rotation.z=universe.planet.rotation.z+2.8051980031399686;

				//Update Sun
				if(show_sun)
				{
					//Get Time
					var time_obj=get_time();
					var time_now=time_obj.hour*60*60+time_obj.minute*60+time_obj.second;
					var time_max=24*60*60;


					//Set Sun Position
					var sun_offset=60;
					universe.sun.longitude=sun_offset+time_now/time_max*360-180;
					universe.sun.latitude=0;

					//Limit Sun Position
					while(universe.sun.longitude>180)
						universe.sun.longitude-=360;
					while(universe.sun.longitude<-180)
						universe.sun.longitude+=360;

					//Set Sun Light
					var sun_radius=10;
					var sun_x=Math.sin((90-universe.sun.latitude)/180*Math.PI)*Math.cos(Math.PI/2+
						(270-universe.sun.longitude)/180*Math.PI)*sun_radius;
					var sun_y=Math.cos((90-universe.sun.latitude)/180*Math.PI)*sun_radius;
					var sun_z=Math.sin((90-universe.sun.latitude)/180*Math.PI)*Math.sin(Math.PI/2+
						(270-universe.sun.longitude)/180*Math.PI)*sun_radius;
					universe.sun.position.set(sun_x,sun_y,sun_z);
				}

				//Limit Kp
				if(kp.x>=0&&kp.x<=9)
				{
					universe.aurora_north.visible=true;
					universe.aurora_south.visible=true;
				}
				else
				{
					universe.aurora_north.visible=false;
					universe.aurora_south.visible=false;
				}

				//Render
				requestAnimationFrame(render);
				renderer.render(scene,camera);
			}

			//Render Fallback Function
			function render_fallback()
			{
				//Get Cavas Div
				var canvas=document.getElementById("canvas");

				//Get Location Select
				var location_select=document.getElementById("locations");

				canvas.innerHTML="<img src='"+root+"images/fallback/"+
					location_select.options[location_select.selectedIndex].value+" "+
					Math.round(kp.x)+".png' width='100%' height='100%'/>";
			}

			//Create Universe Function (Creates Earth Scene)
			function create_universe(scene,radius,segments)
			{
				//Create Star Background
				var ret={};

				if(show_stars)
				{
					ret.stars=new THREE.Mesh
					(
						new THREE.SphereGeometry(90,segments,segments+1),
						new THREE.MeshBasicMaterial
						({
							map:  THREE.ImageUtils.loadTexture(root+"images/simulation/galaxy_starfield.png"),
							side: THREE.BackSide
						})
					);

					scene.add(ret.stars);
				}

				//Create Planet Earth
				ret.planet=new THREE.Mesh
				(
					new THREE.SphereGeometry(radius,segments,segments+1),
					new THREE.MeshPhongMaterial
					({
						map:         THREE.ImageUtils.loadTexture(root+"images/simulation/2_no_clouds_4k.png"),
						//bumpMap:     THREE.ImageUtils.loadTexture(root+"images/simulation/elev_bump_4k.png"),
						//bumpScale:   0.005,
						specularMap: THREE.ImageUtils.loadTexture(root+"images/simulation/water_4k.png"),
						specular:    new THREE.Color('grey')
					})
				);

				scene.add(ret.planet);

				//Create Marker
				var marker_radius=0.005;
				ret.marker=new THREE.Mesh
				(
					new THREE.SphereGeometry(marker_radius,segments,segments+1),
					new THREE.ShaderMaterial
					({
						vertexShader: document.getElementById('marker_vertex_shader').textContent,
						fragmentShader: document.getElementById('marker_fragment_shader').textContent
					})
				);

				ret.marker.radius=marker_radius;
				ret.marker.latitude=0;
				ret.marker.longitude=0;
				scene.add(ret.marker);

				//Create Northern Auroral Oval
				ret.aurora_north=new THREE.Mesh
				(
					new THREE.SphereGeometry
						(
							radius+0.003,segments,segments+1,
							0,Math.PI,0,Math.PI
						),
					new THREE.ShaderMaterial
					({
						transparent: true,
						uniforms:
						{
							kp:{type:"v2",value:kp}
						},
						vertexShader: document.getElementById('aurora_vertex_shader').textContent,
						fragmentShader: document.getElementById('aurora_fragment_shader').textContent
					})
				);

				ret.aurora_north.visible=false;
				scene.add(ret.aurora_north);

				//Create Southern Auroral Oval
				ret.aurora_south=new THREE.Mesh
				(
					new THREE.SphereGeometry
					(
						radius+0.003,segments,segments+1,
						0,Math.PI,0,Math.PI
					),
					new THREE.ShaderMaterial
					({
						transparent: true,
						uniforms:
						{
							kp:{type:"v2",value:kp}
						},
						vertexShader: document.getElementById('aurora_vertex_shader').textContent,
						fragmentShader: document.getElementById('aurora_fragment_shader').textContent
					})
				);

				ret.aurora_south.visible=false;
				scene.add(ret.aurora_south);

				//Create Ambient Light
				ret.ambient_light=new THREE.AmbientLight(0x444444);
				scene.add(ret.ambient_light);

				//Create Sun Light
				if(show_sun)
				{
					ret.sun=new THREE.DirectionalLight(0xffffff,1.5);
					ret.sun.position.set(0,0,0);
					ret.sun.latitude=0;
					ret.sun.longitude=0;
					scene.add(ret.sun);
				}

				//Create Ambient Light
				else
				{
					ret.light=new THREE.AmbientLight(0xaaaaaa,2);
					scene.add(ret.light);
				}

				//Return Scene
				return ret;
			}

			//Set Location
			function set_location()
			{
				//Get Location Select
				var location_select=document.getElementById("locations");

				//Simulation
				if(!use_fallback)
				{
					//Set "To" Location
					view_latitude_to=locations[location_select.selectedIndex].latitude;
					view_longitude_to=locations[location_select.selectedIndex].longitude;

					//Limit Longitude Wrap Around
					while(view_longitude>180)
						view_longitude-=360;
					while(view_longitude<-180)
						view_longitude+=360;

					//Set Marker Location
					universe.marker.latitude=view_latitude_to;
					universe.marker.longitude=view_longitude_to;
				}

				//2D Fallback
				else
				{
					render_fallback();
				}
			}

			//TESTING
			function show_members(obj)
			{
				var methods=[];

				for (var m in obj)
					if (typeof obj[m]=="function"&&obj.hasOwnProperty(m))
						methods.push(m);

				alert(methods.join(","));
			}

			//Get Time Function (Gives UTC by default.)
			function get_time(offset)
			{
				var date=new Date();

				if(offset)
					date.setHours(date.getHours()+offset);

				var ret={};
				ret.second=date.getUTCSeconds();
				ret.minute=date.getUTCMinutes();
				ret.hour=date.getUTCHours();
				ret.day=date.getUTCDate();
				ret.month=date.getMonth()+1;
				ret.year=date.getFullYear();

				return ret;
			}

			//Setup Locations Function
			function setup_locations()
			{
				//Update Location Options
				update_location_options();

				//Update Live Location
				set_location();

				//Get Current Location
				if(!use_fallback)
					navigator.geolocation.getCurrentPosition(get_current_location);
			}

			//Get Current Location Callback
			function get_current_location(location)
			{
				//Get Current Location
				var current_location={name:"My Location",latitude:location.coords.latitude,
					longitude:location.coords.longitude};

				//Insert Into Locations Array
				locations.splice(0,0,current_location);

				//Update Location Options
				update_location_options();

				//Get Location Select
				var location_select=document.getElementById("locations");

				//Auto Set Location
				if(location_select.length>0)
				{
					location_select.selectedIndex=0;
					set_location();
				}
			}

			//Update Location Options Function
			function update_location_options()
			{
				//Get Location Select
				var location_select=document.getElementById("locations");

				//Clear Out Old Options
				location_select.options.length=0;

				//Add Locations
				if(!use_fallback)
				{
					for(var ii=0;ii<locations.length;++ii)
						location_select.options[ii]=new Option(locations[ii].name);
				}
				else
				{
					for(var ii=0;ii<fallback_locations.length;++ii)
						location_select.options[ii]=new Option(fallback_locations[ii].name);

				}
			}

			//Window Resize Function
			function resize_function(event)
			{
				var size=document.body.clientWidth;

				if(!use_fallback)
					renderer.setSize(size,size);
				else
					document.getElementById("canvas").width=document.getElementById("canvas").height=size;

				if(parent.document.getElementById("simulation"))
					parent.document.getElementById("simulation").height=String(size);
			}

			//Mouse Leave Window Callback
			function mouse_leave_window_callback(event)
			{
				event=event?event:window.event;

				var from=event.relatedTarget||event.toElement;

				if(!from||from.nodeName=="HTML")
					mouse_down=false;
			}

			//Mouse Wheel Initialize Function
			function mouse_scroll_init(div)
			{
				var elem=document.getElementById(div);

				if(elem.addEventListener)
				{
					elem.addEventListener("mousewheel",mouse_wheel_callback,false);
					elem.addEventListener("DOMMouseScroll",mouse_wheel_callback,false);
				}
				else
				{
					if(elem.attachEvent)
						elem.attachEvent("onmousewheel",MouseScroll);
				}
			}

			//Mouse Wheel Callback
			function mouse_wheel_callback(event)
			{
				var roll=0;

				if('wheelDelta' in event)
					roll=event.wheelDelta;
				else
					roll=-40*event.detail;

				var canvas=document.getElementById("canvas");

				if(event.target!=canvas||mouse_down)
				{
					zoom+=roll*0.001;
					event.preventDefault();
				}
			}

			//Mouse Down Callback
			function mouse_down_callback(event)
			{
				var canvas=document.getElementById("canvas");

				if(event.target!=canvas)
				{
					mouse_down=true;
					view_latitude_down=view_latitude;
					view_longitude_down=view_longitude;
					mouse_down_x=event.pageX-canvas.offsetLeft;
					mouse_down_y=event.pageY-canvas.offsetTop;
				}
			}

			//Mouse Up Callback
			function mouse_up_callback(event)
			{
				mouse_down=false;
			}

			//Mouse Move Callback
			function mouse_move_callback(event)
			{
				var canvas=document.getElementById("canvas");

				if(mouse_down)
				{
					var mouse_x=event.pageX-canvas.offsetLeft;
					var mouse_y=event.pageY-canvas.offsetTop;

					view_latitude_to=view_latitude_down+mouse_y-mouse_down_y;
					view_longitude_to=view_longitude_down+mouse_down_x-mouse_x;
				}
			}

			//Mouse Over Callback
			function mouse_over_callback(event)
			{
				if(event.target==canvas)
					mouse_down=false;
			}

			//Touch Leave Window Callback
			function touch_leave_window_callback(event)
			{
				event=event?event:window.event;

				var from=event.relatedTarget||event.toElement;

				if(!from||from.nodeName=="HTML")
					mouse_down=false;
			}

			//Touch Down Callback
			function touch_down_callback(event)
			{
				touches=event.touches.length;

				var canvas=document.getElementById("canvas");

				if(event.target!=canvas)
				{
					mouse_down=true;

					view_latitude_down=view_latitude;
					view_longitude_down=view_longitude;

					mouse_down_x=event.changedTouches[0].pageX-canvas.offsetLeft;
					mouse_down_y=event.changedTouches[0].pageY-canvas.offsetTop;

					event.preventDefault();
				}
			}

			//Touch Up Callback
			function touch_up_callback(event)
			{
				mouse_down=false;
			}

			//Touch Move Callback
			function touch_move_callback(event)
			{
				touches=event.touches.length;

				var canvas=document.getElementById("canvas");

				if(mouse_down)
				{
					var mouse_x=event.changedTouches[0].pageX-canvas.offsetLeft;
					var mouse_y=event.changedTouches[0].pageY-canvas.offsetTop;

					view_latitude_to=view_latitude_down+mouse_y-mouse_down_y;
					view_longitude_to=view_longitude_down+mouse_down_x-mouse_x;

					event.preventDefault();
				}
			}

			//Touch Over Callback
			function touch_over_callback(event)
			{
				touches=event.touches.length;

				if(event.target==canvas)
					mouse_down=false;
			}

			//Record 2D Images Function
			function record_2d_images()
			{
				//Create New Zip File
				zip=new JSZip();

				//Download North Pole Images
				universe.marker.visible=false;
				fallback_locations_index=0;
				kp.x=10;
				setTimeout(render_2d_images,1000);
			}

			//Render 2D Images
			function render_2d_images()
			{
				//Shoot Kp 0-9
				if(kp.x<10)
				{
					//Render Scene
					renderer.render();

					//Render Scene
					var data=renderer.domElement.toDataURL();

					//Add File to Zip
					zip.file(fallback_locations[fallback_locations_index].name+" "+
						kp.x+".png",data.substr(data.indexOf(',')+1),{base64:true});

					//Increase Kp
					kp.x=kp.x+1;

					//Increase Location Index
					if(kp.x>=10)
						fallback_locations_index=fallback_locations_index+1;

					//Give Some Time to Download
					setTimeout(render_2d_images,1000);
				}

				//Change Location
				else if(fallback_locations_index<fallback_locations.length)
				{
					var ele=fallback_locations[fallback_locations_index];
					view_latitude=view_latitude_to=ele.latitude;
					view_longitude=view_longitude_to=ele.longitude;
					zoom=ele.zoom;
					kp.x=0;
					setTimeout(render_2d_images,1000);
				}

				//Download Zip
				else
				{
					window.open(window.URL.createObjectURL(zip.generate({type:"blob"})));
					universe.marker.visible=true;
				}
			}

			function json_to_date(json)
			{
				var date=new Date(parseInt(json.year),parseInt(json.month),parseInt(json.day),
					parseInt(json.hour),parseInt(json.minute),0,0);

				return date;
			}

			//Update Kp Function (Gets JSON object containing kp data.)
			function update_kp()
			{
				if(forecast=="now")
					update_nowcast();

				if(forecast=="h1")
					update_h1cast();
			}

			function update_nowcast()
			{
				var time=get_time(-9);
				time.minute=Math.floor(time.minute/15)*15;

				var request_obj={};
				request_obj.forecast=forecast;
				request_obj.predicted_time={year:time.year,month:time.month,day:time.day,
					hour:time.hour,minute:time.minute};

				var url="http://aurora.cs.uaf.edu/cgi-bin/kp_cgi.py?r="+JSON.stringify(request_obj);

				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET",url,true);

				xmlhttp.onreadystatechange=function()
				{
					if(xmlhttp.readyState==4&&xmlhttp.status==200)
					{
						try
						{
							var obj=JSON.parse(xmlhttp.responseText);

							if(obj.values.length>0)
							{
								kp.x=parseInt(obj.values[obj.values.length-1].kp);

								if(use_fallback)
									render_fallback();
							}
						}
						catch(e)
						{}
					}
				}

				xmlhttp.send();
			}

			function update_h1cast()
			{
				var time=get_time(-9);
				time.hour+=1;

				var request_obj={};
				request_obj.forecast=forecast;
				request_obj.predicted_time={year:time.year,month:time.month,day:time.day,
					hour:time.hour,minute:-1};

				var url="http://aurora.cs.uaf.edu/cgi-bin/kp_cgi.py?r="+JSON.stringify(request_obj);

				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET",url,true);

				xmlhttp.onreadystatechange=function()
				{
					if(xmlhttp.readyState==4&&xmlhttp.status==200)
					{
						try
						{
							var obj=JSON.parse(xmlhttp.responseText);

							if(obj.values.length>0)
							{
								kp.x=parseInt(obj.values[obj.values.length-1].kp);

								if(use_fallback)
									render_fallback();
							}
						}
						catch(e)
						{}
					}
				}

				xmlhttp.send();
			}

		</script>

		<!--GLSL Aurora Vertex Shader Source-->
		<script id="aurora_vertex_shader" type="x-shader/x-vertex">

			//UV Coordinates
			varying vec2 uv_coords;

			//Main
			void main()
			{
				//Pass UV Coordinates to Fragment Shader
				uv_coords=uv;

				//Calculate Position
				gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
			}

		</script>

		<!--GLSL Aurora Fragment Shader Source-->
		<script id="aurora_fragment_shader" type="x-shader/x-fragment">

			//UV Coordinates
			varying vec2 uv_coords;

			//Uniforms
			uniform vec2 kp;


			//Map Function (Linear Interpolatation)
			float map(float x,float in_min,float in_max,float out_min,float out_max)
			{
				return (x-in_min)*(out_max-out_min)/(in_max-in_min)+out_min;
			}

			vec4 average(vec4 x,vec4 y)
			{
				return vec4((x.r+y.r)/2.0,(x.g+y.g)/2.0,(x.b+y.b)/2.0,(x.a+y.a)/2.0);
			}

			//Draw Circle Function
			float draw_circle(const float radius,const float thickness)
			{
				vec2 uv_coords_scaled=vec2(uv_coords.x,uv_coords.y);
				vec2 screen_center=vec2(0.5,0.5);
				float radial_distance=abs(distance(uv_coords_scaled,screen_center));
				float ring_distance=abs(radial_distance-radius);
				float color=map(ring_distance,0.0,thickness/2.0,1.0,0.2);
				return color;
			}

			//Draw Aurora Function
			vec4 draw_aurora(const float radius,const float thickness)
			{
				float color=draw_circle(radius,thickness);
				return vec4(max(0.0,color-0.3),color,0.0,color);
			}

			//Draw View Line Function
			vec4 draw_view_line(const float radius,const float thickness)
			{
				float color=draw_circle(radius,thickness);
				return vec4(color,0.0,0.0,color);
			}

			//Main
			void main()
			{
				//Aurora Variables
				float aurora_radius=0.10+kp.x*0.015;
				float aurora_thickness=0.02+kp.x*0.03;

				//View Line Variables
				float view_line_radius=aurora_radius+0.03+kp.x*0.005;
				float view_line_thickness=0.01;

				//Get Aurora Color
				vec4 color_0=draw_aurora(aurora_radius,aurora_thickness);

				//Get View Line Color
				vec4 color_1=draw_view_line(view_line_radius,view_line_thickness);

				//Mix Colors
				gl_FragColor=mix(color_0*2.0,color_1*2.0,0.4);

				//Determine Alpha
				gl_FragColor.a=max(color_0.a,color_1.a)*0.7;
			}

		</script>

		<!--GLSL Marker Vertex Shader Source-->
		<script id="marker_vertex_shader" type="x-shader/x-vertex">

			//Main
			void main()
			{
				//Calculate Position
				gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
			}

		</script>

		<!--GLSL Marker Fragment Shader Source-->
		<script id="marker_fragment_shader" type="x-shader/x-fragment">

			//Main
			void main()
			{
				gl_FragColor=vec4(1.0,0.0,1.0,1.0);
			}

		</script>

	</head>

	<!--Body-->
	<body onload="setup();" style="overflow:hidden;">

		<!--Simulation Canvas-->
		<div id="canvas"></div>

		<!--Locations Div-->
		<div style="position:absolute;bottom:16px;left:20px;">
			<select id="locations" onclick="set_location();" onchange="set_location();"></select>
		</div>

	</body>

</html>
